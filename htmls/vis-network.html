<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <title>使用 vis 中的 Network 功能 绘制关系图</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        #app { position: relative; width: 100%; height: 100vh; }
        #container { width: 100%; height: 100%; background-color: cornflowerblue; }
        #menu-warpper {
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            width: 150px;
            border: 1px solid transparent;
            border-radius: 5px;
            background-color: rgba(0,0,0,0.5);
            box-shadow: 0 0 5px rgba(255,255,255, 0.8);
        }
        .menu-item {
            padding: 10px 20px;
            font-size: 14px;
            letter-spacing: 5px;
            color: #FFF;
            cursor: pointer;
            list-style: none;
        }
        .menu-item:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="container"></div>
        <div id="menu-warpper">
            <ul class="menu-inner">
                <li class="menu-item">添加</li>
                <li class="menu-item">删除</li>
            </ul>
        </div>
    </div>
</body>
<script>
    class Sql {
        constructor() {
            this.db = null
            this.request = null
        }
        connect(sql, version) {
            return new Promise((resolve, reject) => {
                this.request = window.indexedDB.open(sql, version)
                this.request.onsuccess = (e) => {
                    resolve(e)
                    this.db = this.request.result
                    this.success(e, '数据库打开成功')
                }
                this.request.onerror = (e) => {
                    reject(e)
                    this.error(e, '数据库打开报错')
                }
                this.request.onupgradeneeded = (e) => {
                    this.db = e.target.result
                    resolve(e)
                    this.success(null, '数据库升级成功')
                }
            })
        }
        upgrad(e) {
            this.db = e.target.result
        }
        add(sql, value) {
            const request = this.db.transaction([sql], 'readwrite')
                .objectStore(sql)
                .add(value)
            request.onsuccess = (e) => {
                this.success(e, '数据写入成功')
            }
            request.onerror = (e) => {
                this.error(e, '数据写入失败')
            }
        }
        get(sql, value) {
            return new Promise((resolve, reject) => {
                const request = this.db
                    .transaction([sql])
                    .objectStore(sql)
                    .get(value)
                request.onsuccess = () => {
                    resolve(request.result)
                    this.success.call(this, request.result)
                }
                request.onerror = this.error.call(this, '获取失败')
            })
        }
        update(sql, value) {
            const request = this.db
                .transaction([sql], 'readwrite')
                .objectStore(sql)
                .put(value)
            request.onsuccess = this.success.call(this, '数据更新成功')
            request.onerror = this.error.call(this, '数据更新失败')
        }
        delete(sql, value) {
            const request = this.db
                .transaction([sql], 'readwrite')
                .objectStore(sql)
                .delete(value)
            request.onsuccess = this.success.call(this, '数据删除成功')
            request.onerror = this.error.call(this, '数据删除失败')
        }
        cursor(tableName) {
            return new Promise((resolve, reject) => {
                if (this.hasObjectStoreNames(tableName)) {
                    const request = this.db
                        .transaction([tableName])
                        .objectStore(tableName)
                        .openCursor()
                    request.onsuccess = (e) => {
                        resolve(e.target.result)
                        this.success(e, '遍历表数据成功')
                    }
                    request.onerror = (e) => {
                        reject(e)
                        this.error(e, '遍历表数据失败')
                    }
                } else {
                    reject('表不存在')
                }
            })
        }
        createIndex(sql, value) {
            this.db
                .transaction([sql], 'readonly')
                .objectStore(sql)
                .index(value)
        }
        getIndex(sql, key, value) {
            return new Promise((resolve, reject) => {
                const request = this.db
                    .transaction([sql], 'readonly')
                    .objectStore(sql)
                    .index(key)
                    .get(value)
                request.onsuccess = (e) => {
                    const result = e.target.result
                    if (result) {
                        resolve(result)
                    } else {
                        reject(e)
                    }
                }
                request.onerror = () => {
                    reject(e)
                    this.error.call(this, '获取索引失败')
                }
            })
        }

        hasObjectStoreNames(name) {
            if (this.db.objectStoreNames.contains(name)) {
                this.success(null, `${name} 表已存在`)
                return true
            } else {
                this.error(null, `${name} 表不存在`)
                return false
            }
        }

        create(name, data, options = { keyPath: false }) {
            if (!this.db.objectStoreNames.contains(name)) {
                let objectStore = null
                if (options.keyPath) {
                    objectStore = this.db.createObjectStore(name, { keyPath: options.keyPath })
                } else {
                    objectStore = this.db.createObjectStore(name, { autoIncrement: true })
                }
                data.forEach(item => {
                    objectStore.createIndex(item.name, item.name, { unique: item.unique })
                })
            }
        }

        success(e, message) {
            console.log(e, message || 'success')
        }
        error(e, message) {
            console.log(e, message || 'error')
        }
    }
</script>
<script>
    const container = document.getElementById('container')
    const menu_warpper = document.getElementById('menu-warpper')
    let eventOptions = {
        node_seleced: false,
        node_id: 0,
        edge_id: '',
        position: {
            x: 1,
            y: -1
        }
    }
    let network = null
    let sql = null
    let options = {
        autoResize: true,
        height: '100%',
        width: '100%',
        locale: 'en',
        clickToUse: false,
        configure: {},// defined in the configure module.
        edges: {
            arrows: {
                middle: {
                    enabled: true
                }
            }
        },// defined in the edges module.
        nodes: {
            icon: {
                face: 'Ionicons',
                code: '\uf007',
                size: 50,
                color: '#2B7CE9'
            },
            shadow: {
                color: 'rgba(0,0,0,0.5)',
                size: 10,
                x: 5,
                y: 5
            },
            shape: 'circle',
            title: 'title'
        },// defined in the nodes module.
        groups: {},// defined in the groups module.
        layout: {},// defined in the layout module.
        interaction: {
            hover: true
        },// defined in the interaction module.
        manipulation: {},// defined in the manipulation module.
        physics: {}// defined in the physics module.
    }

    const person = [
        { id: 1, label: '原始天尊', pid: 0 },
        { id: 2, label: '南极仙翁', pid: 1 },
        { id: 3, label: '燃灯道人', pid: 1 },
        { id: 4, label: '云中子', pid: 1 },
        { id: 5, label: '广成子', pid: 1 },
        { id: 6, label: '赤精子', pid: 1 },
        { id: 7, label: '黄龙真人', pid: 1 },
        { id: 8, label: '惧留孙', pid: 1 },
        { id: 9, label: '太乙真人', pid: 1 },
        { id: 10, label: '灵宝大师', pid: 1 },
        { id: 11, label: '文殊菩萨', pid: 1 },
        { id: 12, label: '普贤菩萨', pid: 1 },
        { id: 13, label: '观音菩萨', pid: 1 },
        { id: 14, label: '玉鼎真人', pid: 1 },
        { id: 15, label: '道行天尊', pid: 1 },
        { id: 16, label: '清虚道德真君', pid: 1 },
    ]
    
    window.onload = function () {
        // var nodes = new vis.DataSet([
        //     { id: 1, label: '盘古' },
        //     { id: 2, label: '鸿钧' },
        //     { id: 3, label: '女娲' },
        //     { id: 4, label: '伏羲' },
        //     { id: 5, label: '轩辕' },
        //     { id: 6, label: '蚩尤' },
        //     { id: 7, label: '神农' },
        //     { id: 8, label: '大禹' },
        //     { id: 9, label: '共工' },
        //     { id: 10, label: '太上老君' },
        //     { id: 11, label: '原始天尊' },
        //     { id: 12, label: '灵宝道君' },
        //     { id: 13, label: '太乙真人' },
        //     { id: 14, label: '玉鼎真人' },
        //     { id: 15, label: '姜子牙' },
        //     { id: 16, label: '姬昌' },
        //     { id: 17, label: '姬发' },
        //     { id: 18, label: '伯邑考' }
        // ])
        var nodes = new vis.DataSet(person)
        var edges = new vis.DataSet(person.map(v => { return { from: v.pid, to: v.id } }))
        // var edges = new vis.DataSet([
        //     { from: 1, to: 3, label: 'label' },
        //     { from: 1, to: 2, label: 'label' },
        //     { from: 2, to: 10, label: 'label' },
        //     { from: 2, to: 11, label: 'label' },
        //     { from: 2, to: 12, label: 'label' },
        //     { from: 11, to: 13, label: 'label' },
        //     { from: 11, to: 14, label: 'label' },
        //     { from: 11, to: 15, label: 'label' },
        // ])
        var data = {
            nodes: nodes,
            edges: edges
        }
        network = new vis.Network(container, data, options)
        
        container.onclick = function (event) {
            menu_warpper.style.display = 'none'
        }
        container.oncontextmenu = function (event) {
            event.preventDefault()
            if (eventOptions.node_seleced) {
                menu_warpper.style.display = 'block'
                menu_warpper.style.left = event.x + 10 + 'px'
                menu_warpper.style.top = event.y + 'px'
            } else {
                // 取消所有的选中状态。不触发事件。
                network.unselectAll()
            }
        }
        network.on('click', function (properties) {
            console.log(properties)
            const { edges, nodes } = properties
            if (edges[0]) {
                // 选择线
                // network.selectEdges(edges[0])
            }
            if (nodes[0]) {
                eventOptions.node_id = nodes[0]
                const current_node_position = network.getPosition(nodes[0])
                eventOptions.position.x = current_node_position.x
                eventOptions.position.y = current_node_position.y
                // 选择节点
                // network.selectNodes(nodes[0], false)
                // 聚焦节点
                network.focus(nodes[0], {
                    scale: 2,
                    // offset: {x: 0, y: 0},
                    // locked: true,
                    animation: true,
                    // animation: {
                    //     duration: 1000,
                    //     easingFunction: 'easeInOutQuad'
                    // }
                })
            } else {
                // 释放聚焦的节点
                // network.releaseNode()
                // network.focus(eventOptions.node_id, {
                //     scale: 1,
                //     // offset: {x: 0, y: 0},
                //     // locked: true,
                //     animation: true,
                //     // animation: {
                //     //     duration: 1000,
                //     //     easingFunction: 'easeInOutQuad'
                //     // }
                // })
                // 移动节点。 提供的 x 和 y 位置必须在canvas中
                // network.moveNode(eventOptions.node_id, eventOptions.position.x, eventOptions.position.y)
                // network.moveTo({
                //     position: eventOptions.position
                // })
                network.moveTo({
                    position: { x: 1, y: -1 },
                    scale: 1,
                    animation: true
                })
            }
            // 选择节点和线
            // network.setSelection({ nodes, edges })
            if (nodes[0] && nodes[0] === 1) {
                // 缩放节点
                // network.fit({
                //     nodes: [],
                //     animation: true,
                // })
            }
        })
        network.on('hoverNode', function(properties) {
            eventOptions.node_seleced = true
            // eventOptions.node_id = properties.node
            // 获取当前的关系图缩放级别。1.0是100% ，0是无限放大。
            // const scale = network.getScale()
            // console.log({scale})
        })
        network.on('blurNode', function (properties) {
            eventOptions.node_seleced = false
            // eventOptions.node_id = 0
            // 释放聚焦的节点
            network.releaseNode()
            // 获取视图的中心
            const { x, y } = network.getViewPosition()
            console.log({x,y})
            // network.moveTo({
            //     position: { x: x, y: y },
            //     scale: 0.5,
            //     offset: { x: 0, y: 0 },
            //     animation: {
            //         duration: 3,
            //         easingFunction: 'easeOutQuart'
            //     }
            // })
            // 获取当前的关系图缩放级别。1.0是100% ，0是无限放大。
            // network.getScale()
        })
        network.on('contextmenu', function (properties) {
            console.log(properties)
        })
        // 缩放节点
        // network.fit({
        //     nodes: [],
        //     animation: true,
        //     animation: {
        //         duration: 3,
        //         easingFunction: 'ease-in-out'
        //     }
        // })
        sql = new Sql()
        sql.connect('database', 1).then(res => {
            if (sql.hasObjectStoreNames('person')) {
                const request = sql.db.transaction(['person']).objectStore('person').getAll()
                request.onsuccess = function () {
                    const data = request.result
                }
            }
        })
    }
    
</script>
</html>